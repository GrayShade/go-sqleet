package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	// Grab this go file's filename
	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		return fmt.Errorf("Unable to get running go filename")
	}
	copyFromSqlite3Dir := filepath.Join(filepath.Dir(filename), "..", "third-party", "go-sqlite3")
	copyFromSqleetDir := filepath.Join(filepath.Dir(filename), "..", "third-party", "sqleet")
	copyToDir := filepath.Join(filepath.Dir(filename), "..", "sqlite3")

	// Remove existing files
	log.Printf("Removing previously copied files in %v", copyToDir)
	files, err := ioutil.ReadDir(copyToDir)
	if err != nil {
		return fmt.Errorf("Unable to read copy-to dir: %v", err)
	}
	for _, file := range files {
		if file.Name() != "sqleet.go" {
			fileAbs := filepath.Join(copyToDir, file.Name())
			if err = os.Remove(fileAbs); err != nil {
				return fmt.Errorf("Unable to remove %v: %v", fileAbs, err)
			}
		}
	}

	// Copy over go files
	log.Printf("Copying *.go files from %v to %v", copyFromSqlite3Dir, copyToDir)
	if files, err = ioutil.ReadDir(copyFromSqlite3Dir); err != nil {
		return fmt.Errorf("Unable to read copy-from dir: %v", err)
	}
	for _, file := range files {
		if strings.HasSuffix(file.Name(), ".go") {
			err = copyFileWithReplacer(
				filepath.Join(copyFromSqlite3Dir, file.Name()),
				filepath.Join(copyToDir, file.Name()),
				patchGoFile)
			if err != nil {
				return err
			}
		}
	}

	// Copy over c and h files
	log.Printf("Copying over sqleet c/h files from %v to %v", copyFromSqleetDir, copyToDir)
	err = copyFile(filepath.Join(copyFromSqleetDir, "sqleet.c"), filepath.Join(copyToDir, "sqlite3-binding.c"))
	if err == nil {
		err = copyFile(filepath.Join(copyFromSqleetDir, "sqleet.h"), filepath.Join(copyToDir, "sqlite3-binding.h"))
	}
	return err
}

func patchGoFile(fileName string, byts []byte) []byte {
	// Add code-generated header
	byts = append([]byte("// Code generated by update.go. DO NOT EDIT.\n\n"), byts...)
	// Change the registration name
	byts = bytes.Replace(byts, []byte("sql.Register(\"sqlite3"), []byte("sql.Register(\"sqleet"), -1)
	if fileName == "sqlite3.go" {
		// Add a post-create hook
		byts = bytes.Replace(byts,
			[]byte("ConnectHook func(*SQLiteConn) error\n"),
			[]byte("CreateHook func(*SQLiteConn) error\n\tConnectHook func(*SQLiteConn) error\n"), -1)
		// Move params out of if
		byts = bytes.Replace(byts,
			[]byte("pos := strings.IndexRune(dsn, '?')\n"),
			[]byte("var dsnParams url.Values\n\tpos := strings.IndexRune(dsn, '?')\n"), -1)
		byts = bytes.Replace(byts,
			[]byte("params, err := url.ParseQuery(dsn[pos+1:])\n"),
			[]byte("params, err := url.ParseQuery(dsn[pos+1:])\n\t\tdsnParams = params\n"), -1)
		// Call createConn instead of specific creation
		byts = bytes.Replace(byts,
			[]byte("conn := &SQLiteConn{db: db, loc: loc, txlock: txlock}\n"),
			[]byte("conn, err := d.createConn(dsnParams, db, loc, txlock)\n"+
				"\tif err != nil {\n\t\tC.sqlite3_close_v2(db)\n\t\treturn nil, err\n\t}\n"), -1)
	}
	return byts
}

func copyFile(from string, to string) error { return copyFileWithReplacer(from, to, nil) }
func copyFileWithReplacer(from string, to string, replacer func(string, []byte) []byte) error {
	info, err := os.Stat(from)
	if err != nil {
		return fmt.Errorf("Failed getting file info from %v: %v", from, err)
	}
	byts, err := ioutil.ReadFile(from)
	if err != nil {
		return fmt.Errorf("Failed reading %v: %v", from, err)
	}
	if replacer != nil {
		byts = replacer(info.Name(), byts)
	}
	if err = ioutil.WriteFile(to, byts, info.Mode()); err != nil {
		return fmt.Errorf("Failed writing %v: %v", to, err)
	}
	return nil
}
